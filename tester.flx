// Temporarily, test script in top level of repo

open Regdef;

// Start by parsing output from Winterfell run

var result = System::system "cargo run --bin airc -- transpile -i examples/example.air";
println$ "AIRSCIPT result = " + result.str;

result = System::system "cp examples/example.rs examples/tests/winterfell/src/example.rs";
println$ "CP result = " + result.str;
result = System::system "RUSTFLAGS=-Awarnings cargo run --bin winterfell --release";
println$ "WINTERFELL result = " + result.str;

var test_filename = "examples/tests/cairo/test_air.cairo";
var log_filename = "example.wlog";
var text = load log_filename;
var lines = split (text, "\n");
var vlines = varray lines;

var counter = 0;
for line in vlines do
  println$ counter.str + ":  " + line;
  ++counter;
done

regdef digit = charset "0123456789";
regdef number = digit+;
regdef numberz = number (", " number)*;
regdef vector = "(" numberz ")";
regdef narr = "[" numberz? "]";
regdef varr = "[" vector (", " vector)* "]";

println$ "\nPARSE\n";

//0
var lno = 0;
regdef l1 = "public_inputs: " group (narr);
var r1 = RE2 l1.render;
var x1 = Match(r1, vlines.lno);
match x1 with
| Some y => 
  println$  "public_inputs: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//1
++lno;
regdef l1a = "main_transition_constraints - target degree: " group (number);
var r1a = RE2 l1a.render;
var x1a = Match(r1a, vlines.lno);
match x1a with
| Some y => 
  println$  "main_transition_constraints target degree: " + y.1;
var main_transition_constraints_target_degree = y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;


//2
++lno;
regdef l2 = "main_constraint_coeffs: "  group (varr);
var r2 = RE2 l2.render;
var x2 = Match(r2, vlines.lno);
match x2 with
| Some y => 
  println$  "main_constraint_coeffs: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//3
++lno;
regdef l2a = "aux_constraints_number: "  group (number);
var r2a = RE2 l2a.render;
var x2a = Match(r2a, vlines.lno);
match x2a with
| Some y => 
  println$  "aux_constraints_number: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//4
++lno;
regdef l3 = 
  "main_trace_frame: EvaluationFrame { current: "  
   group (narr)
   ", next: "
   group(narr)
   " }"
;
var r3 = RE2 l3.render;
var x3 = Match(r3, vlines.lno);
match x3 with
| Some y => 
  println$  "main_trace_frame: current: " + y.1;
  println$  "main_trace_frame: next: " + y.2;
var main_trace_current = y.1;
var main_trace_next = y.2;

| None => println$ "Parse "+lno.str+" failed";
endmatch;

//5
++lno;
regdef l4 = "aux_trace_frame: " group (narr | "None");
var r4 = RE2 l4.render;
var x4 = Match(r4, vlines.lno);
match x4 with
| Some y => 
  println$  "aux_trace_frame: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//6
++lno;
regdef l5 = "aux_trace_rand_elements: AuxTraceRandElements(" group(narr?) ")";
var r5 = RE2 l5.render;
var x5 = Match(r5, vlines.lno);
match x5 with
| Some y => 
  println$  "L5: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//7
++lno;
regdef l6 = "x: " group(number);
var r6 = RE2 l6.render;
var x6 = Match(r6, vlines.lno);
match x6 with
| Some y => 
  println$  "x: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//8
++lno;
regdef l7 = "periodic_values: " group(narr);
var r7 = RE2 l7.render;
var x7 = Match(r7, vlines.lno);
match x7 with
| Some y => 
  println$  "periodic_values: " + y.1;
var periodic_values = y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//9
++lno;
regdef l8a = "trace_length : " group(number);
var r8a = RE2 l8a.render;
var x8a = Match(r8a, vlines.lno);
match x8a with
| Some y => 
var trace_length= y.1;
  println$ "trace_length: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

//10
++lno;
regdef l8b = "trace_domain_generator: " group(number);
var r8b = RE2 l8b.render;
var x8b = Match(r8b, vlines.lno);
match x8b with
| Some y => 
var trace_domain_generator = y.1;
  println$ "trace_domain_generator: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;


//11
++lno;
regdef l8 = "t_evaluations1: " group(narr);
var r8 = RE2 l8.render;
var x8 = Match(r8, vlines.lno);
match x8 with
| Some y => 
var t_evaluations1 = y.1;
  println$ "t_evaluations1: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

++lno;
regdef l9 = "t_evaluations2: " group(narr);
var r9 = RE2 l9.render;
var x9 = Match(r9, vlines.lno);
match x9 with
| Some y => 
var t_evaluations2 = y.1;
  println$  "t_evaluations2: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

++lno;
regdef l10 = "t_combined: " group(number);
var r10 = RE2 l10.render;
var x10 = Match(r10, vlines.lno);
match x10 with
| Some y => 
  println$  "t_combined: " + y.1;
var t_combined = y.1;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

++lno;
regdef l14 = "main_boundary_constraint_groups_number: " group(number);
var r14 = RE2 l14.render;
var x14 = Match(r14, vlines.lno);
match x14 with
| Some y => 
  println$  "main_boundary_constraint_groups_number: " + y.1;
var main_boundary_constraint_groups_number = y.1.int;
assert main_boundary_constraint_groups_number == 2;
| None => println$ "Parse "+lno.str+" failed";
endmatch;

for constraint_group in 0..main_boundary_constraint_groups_number - 1 do
  ++lno;
  regdef l15 = "constraint_group, number_of_constraints: " group(number) ", denominator: " group(number);
  var r15 = RE2 l15.render;
  var x15 = Match(r15, vlines.lno);
  match x15 with
  | Some y => 
    println$  "group " + constraint_group.str + ", nconstraints "+ y.1+", denominator " + y.2;
    var ncon = y.1.int;
    var den = y.2;
  | None => println$ "Parse "+lno.str+" failed";
  endmatch;
  
  for bcon in 0..ncon - 1 do
    ++lno;
    regdef l16 = "b_column: " group(number) ", trace_value: " group(number) + ", x: "  group(number) + ", evaluation: " group(number);
    var r16 = RE2 l16.render;
    var x16 = Match(r16, vlines.lno);
    match x16 with
    | Some y => 
      var b_column = y.1.int;
      //assert bcon == b_column - 1;
      var trace_value = y.2;
      var x = y.3;
      var evaluation = y.4;
      println$ "group " + constraint_group.str + ", column " + b_column.str + ", x: " + x.str + ", expeced eval = " + evaluation;
    | None => println$ "Parse of boundary data, group " + constraint_group.str + ", column " + bcon.str + " FAILED";  
    endmatch;
  done
done


fun arr2list (x:string) {
  return split(x.[1 to -1],",");
}

var main_trace_len = (main_trace_current,",").split.len;

var output = 
"""
// GENERATED
%lang starknet

from starkware.cairo.common.cairo_builtins import BitwiseBuiltin
from starkware.cairo.common.hash import HashBuiltin
from starkware.cairo.common.alloc import alloc
from examples.tests.cairo.example import EvaluationFrame, evaluate_transition_0

@external
func test_transition_constraints{range_check_ptr}() {
    alloc_locals;
    let (periodic: felt*) = alloc();
"""
+
  {
    var ps = periodic_values.arr2list.varray;
    var s = "";
    for i in 0uz..<ps.len do
      &s <- s + "    assert periodic["+i.str+"] = "+ps.i.str+";\n";
    done
    return s;
  }()
    
+
"""
    let (current_frame: felt*) = alloc();
    let (next_frame: felt*) = alloc();
    %{
        current_frame_ptr = ids.current_frame
        for val in """ + main_trace_current + """:
               memory[current_frame_ptr] = val
               current_frame_ptr = current_frame_ptr + 1

        next_frame_ptr = ids.next_frame
        for next_val in """+main_trace_next+""":
            memory[next_frame_ptr] = next_val
            next_frame_ptr = next_frame_ptr + 1
    %}

    let (t_evaluations: felt*) = alloc();
    local t_evaluations_ptr: felt* = t_evaluations;
    let main_frame = EvaluationFrame("""+main_trace_len.str+""", current_frame, """+main_trace_len.str+""", next_frame);

    evaluate_transition_0(main_frame, t_evaluations, periodic);
    %{
        expected_t_evals = """t_evaluations1+"""
        for i in range("""+main_trace_len.str+"""):
            print(i, memory[ids.t_evaluations_ptr + i])
            assert memory[ids.t_evaluations_ptr + i] == expected_t_evals[i]
    %}
    return ();
}
""";

save(test_filename, output);

result = System::system "cp examples/example.cairo examples/test.cairo ";
println$ "CP result = " + result.str;
result = System::system "protostar --no-color -p unit test";
println$ "PROTOSTAR result = " + result.str;

