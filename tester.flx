// Temporarily, test script in top level of repo
include "web/low_res_time";
open LowResTime;
var tod = #time_t.gmtime.asctime;


open Regdef;

// Start by parsing output from Winterfell run

// RUN AIRSCRIPT 
var result = System::system "cargo run --bin airc -- transpile -i examples/example.air";
println$ "AIRSCIPT result = " + result.str;
if result != 0 perform System::exit result;

// COPY WINTERFELL VERIFIER
result = System::system "cp examples/example.rs examples/tests/winterfell/src/example.rs";
println$ "COPIED example.rs" + result.str;
if result != 0 perform System::exit result;

// GENERATE WINTEFELL PROVER/VERIFIER MAIN
var winterfell_main_filename = "examples/tests/winterfell/src/main.rs"; 

var winterfell_main_text = """
use std::fs::File;
use std::marker::PhantomData;

use example::{ExampleAir, PublicInputs};
use log::LevelFilter;
use std::io::Write;
use winter_air::{FieldExtension, ProofOptions as WinterProofOptions};
use winter_math::{fields::f64::BaseElement as Felt, FieldElement};
use winter_prover::crypto::hashers::Blake3_192;
use winter_prover::crypto::{DefaultRandomCoin, ElementHasher};
use winter_prover::{Prover, Trace, TraceTable};
use winter_verifier::verify;

mod example;

pub struct ExampleProver<H: ElementHasher> {
    options: WinterProofOptions,
    _hasher: PhantomData<H>,
}

impl<H: ElementHasher> ExampleProver<H> {
    pub fn new(options: WinterProofOptions) -> Self {
        Self {
            options,
            _hasher: PhantomData,
        }
    }

    /// Builds an execution trace of the air
    pub fn build_trace(&self, sequence_length: usize, inputs: &[Felt; 16]) -> TraceTable<Felt> {
        assert!(
            sequence_length.is_power_of_two(),
            "sequence length must be a power of 2"
        );

        let mut s = vec![Felt::ONE];
        let mut a = vec![inputs[0]];
        let mut b = vec![inputs[1]];
        let mut c = vec![inputs[2]];

        for i in 1..sequence_length {
            let new_a = Felt::from((i + 1) as u64);
            let new_b = Felt::from((i + 2) as u64);
            s.push(Felt::ONE); // selector stays the same
            a.push(new_a);
            b.push(new_b);
            c.push(new_a * new_b); // c is a * b
        }

        TraceTable::init(vec![s, a, b, c])
    }
}

impl<H: ElementHasher> Prover for ExampleProver<H>
where
    H: ElementHasher<BaseField = Felt>,
{
    type BaseField = Felt;
    type Air = ExampleAir;
    type Trace = TraceTable<Felt>;
    type HashFn = H;
    type RandomCoin = DefaultRandomCoin<Self::HashFn>;

    fn get_pub_inputs(&self, trace: &Self::Trace) -> PublicInputs {
        // based on air, c = a * b and therefore all 1s
        let inputs = [Felt::ONE; 16];
        let mut outputs = [Felt::ONE; 16];
        let last_step = trace.length() - 2; // why is this 2?
        outputs[0] = trace.get(1, last_step); // a
        outputs[1] = trace.get(2, last_step); // b
        outputs[2] = trace.get(3, last_step); // c
        PublicInputs::new(inputs, outputs)
    }

    fn options(&self) -> &WinterProofOptions {
        &self.options
    }
}

fn main() {
    let inputs = [Felt::ONE; 16];
    let options = WinterProofOptions::new(27, 8, 16, FieldExtension::None, 8, 255);
    let prover = ExampleProver::<Blake3_192<Felt>>::new(options);
    let trace = prover.build_trace(8, &inputs);
    let pub_inputs = prover.get_pub_inputs(&trace);
    let proof = prover.prove(trace).unwrap();
    let example_log = File::create("example.wlog").unwrap();

    // only print verifier
    env_logger::Builder::new()
        .format_timestamp(None)
        .format(|buf, record| writeln!(buf, "{}", record.args()))
        .filter(None, LevelFilter::Info)
        .target(env_logger::Target::Pipe(Box::new(example_log)))
        .init();
    verify::<ExampleAir, Blake3_192<Felt>, DefaultRandomCoin<Blake3_192<Felt>>>(proof, pub_inputs)
        .unwrap();
}
""";
save(winterfell_main_filename, winterfell_main_text);
println$ "SAVED " + winterfell_main_filename;

// RUN WINTERFELL to get required data and results for comparison
result = System::system "RUSTFLAGS=-Awarnings cargo run --bin winterfell --release";
println$ "WINTERFELL result = " + result.str;
if result != 0 perform System::exit result;

// PARSE PUBLIC INPUT NAMES FILE

var pubs = (load("example.public"),"\n").split.varray;
var pub_inputs = pubs.len - 1; // due to trailing newline
println$ "PUBLIC INPUT COUNT = " + pub_inputs.str; 
var pub_data = varray[string * int] pub_inputs.size;
begin
  regdef pubdesc = group (perl("\\w+")) " " group (perl("\\d+"));
  var pubdesc_r = RE2 pubdesc.render;
  for i in 0uz .. pub_inputs - 1uz do
    var xx = Match(pubdesc_r, pubs.i);
    match xx with
    | Some v =>
       var name = v.1;
       var siz = v.2.int;
       push_back(pub_data, (name,siz.int));
       println$ "Public input '" + name + "', length " + siz.str;
    | None =>
      println$ "FAILURE PARSING PUBLIC INPUT NAMES '" + pubs.i+"'";
      System::exit 42;
    endmatch;
  done
end

// PARSE WINTERFELL GENERATED LOG FILE 
var test_filename = "examples/tests/cairo/test_air.cairo";
var log_filename = "example.wlog";
var text = load log_filename;
var lines = split (text, "\n");
var vlines = varray lines;

var counter = 0;
for line in vlines do
  println$ counter.str + ":  " + line;
  ++counter;
done

regdef digit = charset "0123456789";
regdef number = digit+;
regdef numberz = number (", " number)*;
regdef vector = "(" numberz ")";
regdef narr = "[" numberz? "]";
regdef varr = "[" vector (", " vector)* "]";

println$ "\nPARSE\n";

//0
var lno = 0;
regdef l1 = "public_inputs: " group (narr);
var r1 = RE2 l1.render;
var x1 = Match(r1, vlines.lno);
match x1 with
| Some y => 
var public_inputs = y.1;
  println$  "public_inputs: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//1
++lno;
regdef l1a = "main_transition_constraints - target degree: " group (number);
var r1a = RE2 l1a.render;
var x1a = Match(r1a, vlines.lno);
match x1a with
| Some y => 
  println$  "main_transition_constraints target degree: " + y.1;
var main_transition_constraints_target_degree = y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;


//2
++lno;
//regdef l2 = "main_constraint_coeffs: "  group (varr);
//var r2 = RE2 l2.render;
//var x2 = Match(r2, vlines.lno);
//match x2 with
//| Some y => 
//var main_constraint_coeffs = y.1;
  //println$  "main_constraint_coeffs: " + y.1;
//| None => println$ "Parse "+lno.str+" failed";
  //System::exit 42;
//endmatch;

//3
++lno;
regdef l2a = "aux_constraints_number: "  group (number);
var r2a = RE2 l2a.render;
var x2a = Match(r2a, vlines.lno);
match x2a with
| Some y => 
  println$  "aux_constraints_number: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//4
++lno;
regdef l3 = 
  "main_trace_frame: EvaluationFrame { current: "  
   group (narr)
   ", next: "
   group(narr)
   " }"
;
var r3 = RE2 l3.render;
var x3 = Match(r3, vlines.lno);
match x3 with
| Some y => 
  println$  "main_trace_frame: current: " + y.1;
  println$  "main_trace_frame: next: " + y.2;
var main_trace_current = y.1;
var main_trace_next = y.2;
var main_trace_width = (main_trace_current,",").split.len;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//5
++lno;
regdef l4 = "aux_trace_frame: " group (narr | "None");
var r4 = RE2 l4.render;
var x4 = Match(r4, vlines.lno);
match x4 with
| Some y => 
  println$  "aux_trace_frame: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//6
++lno;
regdef l5 = "aux_trace_rand_elements: AuxTraceRandElements(" group(narr?) ")";
var r5 = RE2 l5.render;
var x5 = Match(r5, vlines.lno);
match x5 with
| Some y => 
  println$  "aux_trace_rand_elements: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//7
++lno;
regdef l6 = "x: " group(number);
var r6 = RE2 l6.render;
var x6 = Match(r6, vlines.lno);
match x6 with
| Some y => 
  println$  "x: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//8
++lno;
regdef l7 = "periodic_values: " group(narr);
var r7 = RE2 l7.render;
var x7 = Match(r7, vlines.lno);
match x7 with
| Some y => 
  println$  "periodic_values: " + y.1;
var periodic_values = y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//9
++lno;
regdef l8a = "trace_length: " group(number);
var r8a = RE2 l8a.render;
var x8a = Match(r8a, vlines.lno);
match x8a with
| Some y => 
var trace_length= y.1.int;
  println$ "trace_length: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//10
++lno;
regdef l8b = "trace_domain_generator: " group(number);
var r8b = RE2 l8b.render;
var x8b = Match(r8b, vlines.lno);
match x8b with
| Some y => 
var trace_domain_generator = y.1;
  println$ "trace_domain_generator: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l18c = "composition_coefficients: ConstraintCompositionCoefficients { " 
"transition: " group(varr) ", "
"boundary: " group(varr) 
" }";
var r18c = RE2 l18c.render;
var x18c = Match(r18c, vlines.lno);
match x18c with 
| Some y =>
var main_t_coeffs= y.1;
var main_b_coeffs = y.2;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l18d = "blowup_factor: " group(number);
var r18d = RE2 l18d.render;
var x18d = Match(r18d, vlines.lno);
match x18d with
| Some y => 
var blowup_factor = y.1.int;
  println$ "blowup_factor: " +  blowup_factor.str;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;


//13
++lno;
regdef l8 = "t_evaluations1: " group(narr);
var r8 = RE2 l8.render;
var x8 = Match(r8, vlines.lno);
match x8 with
| Some y => 
var t_evaluations1 = y.1;
  println$ "t_evaluations1: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l9 = "t_evaluations2: " group(narr);
var r9 = RE2 l9.render;
var x9 = Match(r9, vlines.lno);
match x9 with
| Some y => 
var t_evaluations2 = y.1;
  println$  "t_evaluations2: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;
++lno;
++lno;
regdef l10 = "t_combined: " group(number);
var r10 = RE2 l10.render;
var x10 = Match(r10, vlines.lno);
match x10 with
| Some y => 
  println$  "t_combined: " + y.1;
var t_combined = y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l14 = "main_boundary_constraint_groups_number: " group(number);
var r14 = RE2 l14.render;
var x14 = Match(r14, vlines.lno);
match x14 with
| Some y => 
  println$  "main_boundary_constraint_groups_number: " + y.1;
var main_boundary_constraint_groups_number = y.1.int;
assert main_boundary_constraint_groups_number == 2;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

var b_trace = varray[string](main_trace_width * 2uz,"0");
var b_divisor_offsets = varray[string] main_boundary_constraint_groups_number.size;
var b_nsteps = varray[int] main_boundary_constraint_groups_number.size;
var total_bconstraints = 0;
var b_expected_evals_list = Empty[string];

for constraint_group in 0..main_boundary_constraint_groups_number - 1 do
  ++lno;
  regdef l15a = "b_constraint_group divisor_offset: " group(number) ", num_steps: " group(number);
  var r15a = RE2 l15a.render;
  var x15a = Match(r15a, vlines.lno);
  match x15a with
  | Some y =>
    push_back(b_divisor_offsets, y.1);
    push_back(b_nsteps, y.2.int);
  | None => println$ "Parse "+lno.str+" failed";
    System::exit 42;
  endmatch;

  ++lno;
  regdef l15 = "constraint_group, number_of_constraints: " group(number) ", denominator: " group(number);
  var r15 = RE2 l15.render;
  var x15 = Match(r15, vlines.lno);
  match x15 with
  | Some y => 
    println$  "group " + constraint_group.str + ", nconstraints "+ y.1+", denominator " + y.2;
    var ncon = y.1.int;
total_bconstraints += ncon;
    var den = y.2;
  | None => println$ "Parse "+lno.str+" failed";
    System::exit 42;
  endmatch;
  
  for bcon in 0..ncon - 1 do
    ++lno;
    regdef l16 = "b_column: " group(number) ", trace_value: " group(number) + ", x: "  group(number) + ", evaluation: " group(number);
    var r16 = RE2 l16.render;
    var x16 = Match(r16, vlines.lno);
    match x16 with
    | Some y => 
      var b_column = y.1.int;
      //assert bcon == b_column - 1;
      var trace_value = y.2;
      var x = y.3;
      var evaluation = y.4;
      b_expected_evals_list = Cons (evaluation, b_expected_evals_list);
      set (b_trace, b_column.size + main_trace_width * constraint_group.size, trace_value);

      println$ "group " + constraint_group.str + ", column " + b_column.str + ", x: " + x.str + ", expeced eval = " + evaluation;
    | None => println$ "Parse of boundary data, group " + constraint_group.str + ", column " + bcon.str + " FAILED";  
      System::exit 42;
    endmatch;
  done
done

var b_expected_evals = varray (rev(b_expected_evals_list));


println$ "WLOG PARSE COMPLETE OK";

//println$ "Boundary trace row " + b_trace.str;
//println$ "Boundary expected evals " + b_expected_evals.str;
var py_bevals = "[";
for s in b_expected_evals perform py_bevals += s +", ";
py_bevals += "]";
//println$ "Boundary expected evals (as python) " + py_bevals;

var t_coeffs = (main_t_coeffs.[1 to -1],",").split;
//println$ "SPLIT COEFFS = " + coeffs.str;
var n_t_coeffs = t_coeffs.len / 2uz;
var t_coeffs_a = varray[string] n_t_coeffs;
var t_coeffs_b = varray[string] n_t_coeffs;
regdef num = (" " | "(" | " (")? group(number) ")"?;
var t_num_r = RE2 num.render;
var t_count = 0uz;
for e in t_coeffs do
  match Match (t_num_r, e) with
  | Some y => println$ y.1;
    if t_count % 2uz == 0uz do push_back(t_coeffs_a, y.1); else push_back(t_coeffs_b, y.1); done
    ++t_count;
  | None => println$ "PARSE FAIL TRANSITION COEFFS";
  endmatch;
done

var b_coeffs = (main_b_coeffs.[1 to -1],",").split;
//println$ "SPLIT COEFFS = " + coeffs.str;
var n_b_coeffs = b_coeffs.len / 2uz;
var b_coeffs_a = varray[string] n_b_coeffs;
var b_coeffs_b = varray[string] n_b_coeffs;
regdef b_num = (" " | "(" | " (")? group(number) ")"?;
var b_num_r = RE2 b_num.render;
var b_count = 0uz;
for e in b_coeffs do
  match Match (b_num_r, e) with
  | Some y => println$ y.1;
    if b_count % 2uz == 0uz do push_back(b_coeffs_a, y.1); else push_back(b_coeffs_b, y.1); done
    ++b_count;
  | None => println$ "PARSE FAIL TRANSITION COEFFS";
  endmatch;
done

fun arr2list (x:string) {
  return split(x.[1 to -1],",");
}


// GENERATE CAIRO VERIFIER
var output = 
"""
// GENERATED """ + tod + """
%lang starknet

from starkware.cairo.common.cairo_builtins import BitwiseBuiltin
from starkware.cairo.common.hash import HashBuiltin
from starkware.cairo.common.alloc import alloc
from examples.tests.cairo.example import EvaluationFrame, evaluate_transition_0, evaluate_boundary_0, merge_transitions_0, merge_boundary_0
from math_goldilocks import add_g, sub_g, mul_g, pow_g, div_g

@external
func test_transition_constraints{range_check_ptr}() {
    alloc_locals;
    let (periodic: felt*) = alloc();
"""
+
  {
    var ps = periodic_values.arr2list.varray;
    var s = "";
    for i in 0uz..<ps.len do
      &s <- s + "    assert periodic["+i.str+"] = "+ps.i.str+";\n";
    done
    return s;
  }()
    
+
"""
    let (current_frame: felt*) = alloc();
    let (next_frame: felt*) = alloc();
    %{
        current_frame_ptr = ids.current_frame
        for val in """ + main_trace_current + """:
               memory[current_frame_ptr] = val
               current_frame_ptr = current_frame_ptr + 1

        next_frame_ptr = ids.next_frame
        for next_val in """+main_trace_next+""":
            memory[next_frame_ptr] = next_val
            next_frame_ptr = next_frame_ptr + 1
    %}

    let (t_evaluations: felt*) = alloc();
    local t_evaluations_ptr: felt* = t_evaluations;
    let main_frame = EvaluationFrame("""+main_trace_width.str+""", current_frame, """+main_trace_width.str+""", next_frame);

    evaluate_transition_0(main_frame, t_evaluations, periodic);
    %{
        expected_t_evals = """t_evaluations1+"""
        print("Transition Evaluations")
        for i in range("""+main_trace_width.str+"""):
            print(i, memory[ids.t_evaluations_ptr + i])
            assert memory[ids.t_evaluations_ptr + i] == expected_t_evals[i]
    %}

    let (b_current_frame: felt*) = alloc();
    let (b_next_frame: felt*) = alloc();
"""
+
  { 
    var s = "\n  // public inputs\n";
    var p = (public_inputs.[1 to -1], ",").split.varray;
    var ixno = 0;
    for pd in pub_data do
      var name = pd.0;
      s = s + "\n    let ("+name+": felt*) = alloc();\n";
      for lno in 0..<pd.1 do
        s = s + "    assert "+name+"["+lno.str+"] = " + p.ixno + ";\n";
        ++ixno;
      done
    done
    return s;
  } ()
+
"""
  // Trace
"""
+
  { 
    var lno = 0;
    var s = "";
    for inp in b_trace do 
      s = s + "    assert b_current_frame["+lno.str+"] = " + inp + ";\n";
      ++lno;
    done
    return s;
  } ()

+
"""
    let b_frame = EvaluationFrame("""+(main_trace_width * 2uz).str +""", b_current_frame, """+(main_trace_width * 2uz).str+""", next_frame);

    let (b_evaluations: felt*) = alloc();
    local b_evaluations_ptr: felt* = b_evaluations;
    evaluate_boundary_0(b_frame, b_evaluations, """
+ 
  #{
    var s = "";
    for i in 0uz ..< pub_data.len do
      if i != 0uz perform s = s + ", ";
      s = s + pub_data.i.0;
    done
    return s;
  }
+
""");

    %{
        expected_b_evals = """+py_bevals+"""
        print("Boundary Evaluations")
        for i in range("""+(total_bconstraints).str+"""):
            print(i, memory[ids.b_evaluations_ptr + i])
            assert memory[ids.b_evaluations_ptr + i] == expected_b_evals[i]
    %}

"""
+
  #{
    var s = "    let (coeffs_transition_a: felt*) = alloc();\n";
    var counter = 0;
    for x in t_coeffs_a do
      s = s + "    assert coeffs_transition_a["+counter.str+"] = " + x + ";\n";
      ++counter;
    done
    s = s + "    let (coeffs_transition_b: felt*) = alloc();\n";
    counter = 0;
    for x in t_coeffs_b do
      s = s + "    assert coeffs_transition_b["+counter.str+"] = " + x + ";\n";
      ++counter;
    done
    return s;
  }
+
"""
    // FROM PROVER
    let x = """ + x + """;
    let trace_length = """+ trace_length.str + """;
    let trace_domain_generator = """ + trace_domain_generator + """;
    let blowup_factor = """ + blowup_factor.str + """;
    let npub_steps = """ + b_nsteps.1.str + """;
    let main_transition_constraints_target_degree = """ + main_transition_constraints_target_degree.str + """;


    let t_combined = merge_transitions_0(  
      trace_length,  
      main_transition_constraints_target_degree,
      coeffs_transition_a, coeffs_transition_b, 
      t_evaluations, 
      x, 
      trace_domain_generator
     );

    %{
        print(ids.t_combined)
        assert ids.t_combined == """ + t_combined.str + """ 
    %}
"""
+
  #{
    var s = "    let (coeffs_boundary_a: felt*) = alloc();\n";
    var counter = 0;
    for x in b_coeffs_a do
      s = s + "    assert coeffs_boundary_a["+counter.str+"] = " + x + ";\n";
      ++counter;
    done
    s = s + "    let (coeffs_boundary_b: felt*) = alloc();\n";
    counter = 0;
    for x in b_coeffs_b do
      s = s + "    assert coeffs_boundary_b["+counter.str+"] = " + x + ";\n";
      ++counter;
    done
    return s;
  }
+
"""

    let b_combined = merge_boundary_0(
     trace_length,
     blowup_factor, 
     coeffs_boundary_a, coeffs_boundary_b, b_evaluations,  
     trace_domain_generator, npub_steps, x ); 
%{
print("b_combined = ", ids.b_combined)
print("Expected 4219772168637362433")
%}
    return ();
}
""";

save(test_filename, output);

// COPY VERIFIER TO WHERE PROTOSTAR CAN FIND IT
result = System::system "cp examples/example.cairo examples/tests/cairo/example.cairo";
println$ "CP result = " + result.str;

// RUN PROTOSTAR CAIRO VERIFIER TEST
result = System::system "protostar --no-color -p unit test";
println$ "PROTOSTAR result = " + result.str;


