// Temporarily, test script in top level of repo
include "web/low_res_time";
open LowResTime;
var tod = #time_t.gmtime.asctime;


open Regdef;

// Start by parsing output from Winterfell run

var result = System::system "cargo run --bin airc -- transpile -i examples/example.air";
println$ "AIRSCIPT result = " + result.str;
if result != 0 perform System::exit result;

result = System::system "cp examples/example.rs examples/tests/winterfell/src/example.rs";
println$ "CP result = " + result.str;
result = System::system "RUSTFLAGS=-Awarnings cargo run --bin winterfell --release";
println$ "WINTERFELL result = " + result.str;
if result != 0 perform System::exit result;

var test_filename = "examples/tests/cairo/test_air.cairo";
var log_filename = "example.wlog";
var text = load log_filename;
var lines = split (text, "\n");
var vlines = varray lines;

var counter = 0;
for line in vlines do
  println$ counter.str + ":  " + line;
  ++counter;
done

regdef digit = charset "0123456789";
regdef number = digit+;
regdef numberz = number (", " number)*;
regdef vector = "(" numberz ")";
regdef narr = "[" numberz? "]";
regdef varr = "[" vector (", " vector)* "]";

println$ "\nPARSE\n";

//0
var lno = 0;
regdef l1 = "public_inputs: " group (narr);
var r1 = RE2 l1.render;
var x1 = Match(r1, vlines.lno);
match x1 with
| Some y => 
var public_inputs = y.1;
  println$  "public_inputs: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//1
++lno;
regdef l1a = "main_transition_constraints - target degree: " group (number);
var r1a = RE2 l1a.render;
var x1a = Match(r1a, vlines.lno);
match x1a with
| Some y => 
  println$  "main_transition_constraints target degree: " + y.1;
var main_transition_constraints_target_degree = y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;


//2
++lno;
regdef l2 = "main_constraint_coeffs: "  group (varr);
var r2 = RE2 l2.render;
var x2 = Match(r2, vlines.lno);
match x2 with
| Some y => 
  println$  "main_constraint_coeffs: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//3
++lno;
regdef l2a = "aux_constraints_number: "  group (number);
var r2a = RE2 l2a.render;
var x2a = Match(r2a, vlines.lno);
match x2a with
| Some y => 
  println$  "aux_constraints_number: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//4
++lno;
regdef l3 = 
  "main_trace_frame: EvaluationFrame { current: "  
   group (narr)
   ", next: "
   group(narr)
   " }"
;
var r3 = RE2 l3.render;
var x3 = Match(r3, vlines.lno);
match x3 with
| Some y => 
  println$  "main_trace_frame: current: " + y.1;
  println$  "main_trace_frame: next: " + y.2;
var main_trace_current = y.1;
var main_trace_next = y.2;
var main_trace_width = (main_trace_current,",").split.len;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//5
++lno;
regdef l4 = "aux_trace_frame: " group (narr | "None");
var r4 = RE2 l4.render;
var x4 = Match(r4, vlines.lno);
match x4 with
| Some y => 
  println$  "aux_trace_frame: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//6
++lno;
regdef l5 = "aux_trace_rand_elements: AuxTraceRandElements(" group(narr?) ")";
var r5 = RE2 l5.render;
var x5 = Match(r5, vlines.lno);
match x5 with
| Some y => 
  println$  "aux_trace_rand_elements: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//7
++lno;
regdef l6 = "x: " group(number);
var r6 = RE2 l6.render;
var x6 = Match(r6, vlines.lno);
match x6 with
| Some y => 
  println$  "x: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//8
++lno;
regdef l7 = "periodic_values: " group(narr);
var r7 = RE2 l7.render;
var x7 = Match(r7, vlines.lno);
match x7 with
| Some y => 
  println$  "periodic_values: " + y.1;
var periodic_values = y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//9
++lno;
regdef l8a = "trace_length: " group(number);
var r8a = RE2 l8a.render;
var x8a = Match(r8a, vlines.lno);
match x8a with
| Some y => 
var trace_length= y.1.int;
  println$ "trace_length: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

//10
++lno;
regdef l8b = "trace_domain_generator: " group(number);
var r8b = RE2 l8b.render;
var x8b = Match(r8b, vlines.lno);
match x8b with
| Some y => 
var trace_domain_generator = y.1;
  println$ "trace_domain_generator: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;


//11
++lno;
regdef l8 = "t_evaluations1: " group(narr);
var r8 = RE2 l8.render;
var x8 = Match(r8, vlines.lno);
match x8 with
| Some y => 
var t_evaluations1 = y.1;
  println$ "t_evaluations1: " +  y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l9 = "t_evaluations2: " group(narr);
var r9 = RE2 l9.render;
var x9 = Match(r9, vlines.lno);
match x9 with
| Some y => 
var t_evaluations2 = y.1;
  println$  "t_evaluations2: " + y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l10 = "t_combined: " group(number);
var r10 = RE2 l10.render;
var x10 = Match(r10, vlines.lno);
match x10 with
| Some y => 
  println$  "t_combined: " + y.1;
var t_combined = y.1;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

++lno;
regdef l14 = "main_boundary_constraint_groups_number: " group(number);
var r14 = RE2 l14.render;
var x14 = Match(r14, vlines.lno);
match x14 with
| Some y => 
  println$  "main_boundary_constraint_groups_number: " + y.1;
var main_boundary_constraint_groups_number = y.1.int;
assert main_boundary_constraint_groups_number == 2;
| None => println$ "Parse "+lno.str+" failed";
  System::exit 42;
endmatch;

var b_trace = varray[string](main_trace_width * 2uz,"0");
var b_expected_evals = varray[string](main_trace_width * 2uz,"0");

for constraint_group in 0..main_boundary_constraint_groups_number - 1 do
  ++lno;
  regdef l15 = "constraint_group, number_of_constraints: " group(number) ", denominator: " group(number);
  var r15 = RE2 l15.render;
  var x15 = Match(r15, vlines.lno);
  match x15 with
  | Some y => 
    println$  "group " + constraint_group.str + ", nconstraints "+ y.1+", denominator " + y.2;
    var ncon = y.1.int;
    var den = y.2;
  | None => println$ "Parse "+lno.str+" failed";
    System::exit 42;
  endmatch;
  
  for bcon in 0..ncon - 1 do
    ++lno;
    regdef l16 = "b_column: " group(number) ", trace_value: " group(number) + ", x: "  group(number) + ", evaluation: " group(number);
    var r16 = RE2 l16.render;
    var x16 = Match(r16, vlines.lno);
    match x16 with
    | Some y => 
      var b_column = y.1.int;
      //assert bcon == b_column - 1;
      var trace_value = y.2;
      var x = y.3;
      var evaluation = y.4;
set (b_expected_evals, b_column.size + main_trace_width * constraint_group.size, evaluation);
set (b_trace, b_column.size + main_trace_width * constraint_group.size, trace_value);

      println$ "group " + constraint_group.str + ", column " + b_column.str + ", x: " + x.str + ", expeced eval = " + evaluation;
    | None => println$ "Parse of boundary data, group " + constraint_group.str + ", column " + bcon.str + " FAILED";  
      System::exit 42;
    endmatch;
  done
done

println$ "WLOG PARSE COMPLETE OK";

println$ "Boundary trace row " + b_trace.str;
println$ "Boundary expected evals " + b_expected_evals.str;
var py_bevals = "[";
for s in b_expected_evals perform py_bevals += s +", ";
py_bevals += "]";
println$ "Boundary expected evals (as python) " + py_bevals;



fun arr2list (x:string) {
  return split(x.[1 to -1],",");
}

var output = 
"""
// GENERATED """ + tod + """
%lang starknet

from starkware.cairo.common.cairo_builtins import BitwiseBuiltin
from starkware.cairo.common.hash import HashBuiltin
from starkware.cairo.common.alloc import alloc
from examples.tests.cairo.example import EvaluationFrame, evaluate_transition_0, evaluate_boundary_0

@external
func test_transition_constraints{range_check_ptr}() {
    alloc_locals;
    let (periodic: felt*) = alloc();
"""
+
  {
    var ps = periodic_values.arr2list.varray;
    var s = "";
    for i in 0uz..<ps.len do
      &s <- s + "    assert periodic["+i.str+"] = "+ps.i.str+";\n";
    done
    return s;
  }()
    
+
"""
    let (current_frame: felt*) = alloc();
    let (next_frame: felt*) = alloc();
    %{
        current_frame_ptr = ids.current_frame
        for val in """ + main_trace_current + """:
               memory[current_frame_ptr] = val
               current_frame_ptr = current_frame_ptr + 1

        next_frame_ptr = ids.next_frame
        for next_val in """+main_trace_next+""":
            memory[next_frame_ptr] = next_val
            next_frame_ptr = next_frame_ptr + 1
    %}

    let (t_evaluations: felt*) = alloc();
    local t_evaluations_ptr: felt* = t_evaluations;
    let main_frame = EvaluationFrame("""+main_trace_width.str+""", current_frame, """+main_trace_width.str+""", next_frame);

    evaluate_transition_0(main_frame, t_evaluations, periodic);
    %{
        expected_t_evals = """t_evaluations1+"""
        print("Transition Evaluations")
        for i in range("""+main_trace_width.str+"""):
            print(i, memory[ids.t_evaluations_ptr + i])
            assert memory[ids.t_evaluations_ptr + i] == expected_t_evals[i]
    %}

    let (b_current_frame: felt*) = alloc();
    let (B_next_frame: felt*) = alloc();
    let (public: felt*) = alloc();
"""
+
  { 
    var p = (public_inputs.[1 to -1], ",").split.varray;
    var lno = 0;
    var s = "";
    for inp in p do 
      s = s + "    assert public["+lno.str+"] = " + inp + ";\n";
      ++lno;
    done
    return s;
  } ()
+
"""
  // Trace
"""
+
  { 
    var lno = 0;
    var s = "";
    for inp in b_trace do 
      s = s + "    assert b_current_frame["+lno.str+"] = " + inp + ";\n";
      ++lno;
    done
    return s;
  } ()

+
"""
    let b_frame = EvaluationFrame("""+(main_trace_width * 2uz).str +""", b_current_frame, """+(main_trace_width * 2uz).str+""", next_frame);

    let (b_evaluations: felt*) = alloc();
    local b_evaluations_ptr: felt* = b_evaluations;
    evaluate_boundary_0(b_frame, b_evaluations, public);

    %{
        expected_b_evals = """+py_bevals+"""
        print("Boundary Evaluations")
        for i in range("""+(main_trace_width * 2uz).str+"""):
            print(i, memory[ids.b_evaluations_ptr + i])
            assert memory[ids.b_evaluations_ptr + i] == expected_b_evals[i]
    %}


    return ();
}
""";

save(test_filename, output);

result = System::system "cp examples/example.cairo examples/tests/cairo/example.cairo";
println$ "CP result = " + result.str;

result = System::system "protostar --no-color -p unit test";
println$ "PROTOSTAR result = " + result.str;

