// Temporarily, test script in top level of repo

open Regdef;

// Start by parsing output from Winterfell run

var test_filename = "examples/tests/cairo/test_air.cairo";

var log_filename = "example.wlog";
var text = load log_filename;
var lines = split (text, "\n");
var vlines = varray lines;

var counter = 1;
for line in vlines do
  println$ counter.str + ":  " + line;
  ++counter;
done
// Line 1: constraint coeffs

regdef digit = charset "0123456789";
regdef number = digit+;
regdef numberz = number (", " number)*;
regdef vector = "(" numberz ")";
regdef narr = "[" numberz? "]";
regdef varr = "[" vector (", " vector)* "]";

regdef l1 = "public_inputs: " group (narr);
var r1 = RE2 l1.render;
var x1 = Match(r1, vlines.0);
match x1 with
| Some y => 
  println$  "L1: " + y.1;
| None => println$ "Parse 1 failed";
endmatch;

regdef l2 = 
  "composition_coefficients: ConstraintCompositionCoefficients { transition: "  
   group (varr)
   ", boundary: "
   group(varr)
   " }"
;
var r2 = RE2 l2.render;
var x2 = Match(r2, vlines.1);
match x2 with
| Some y => 
  println$  "L2: " + y.1;
| None => println$ "Parse 2 failed";
endmatch;

regdef l3 = 
  "main_trace_frame: EvaluationFrame { current: "  
   group (narr)
   ", next: "
   group(narr)
   " }"
;
var r3 = RE2 l3.render;
var x3 = Match(r3, vlines.2);
match x3 with
| Some y => 
  println$  "L3: " + y.1 + y.2;
var main_trace_current = y.1;
var main_trace_next = y.2;

| None => println$ "Parse 3 failed";
endmatch;

regdef l4 = "aux_trace_frame: " group (narr | "None");
var r4 = RE2 l4.render;
var x4 = Match(r4, vlines.3);
match x4 with
| Some y => 
  println$  "L4: " + y.1;
| None => println$ "Parse 4 failed";
endmatch;

regdef l5 = "aux_trace_rand_elements: AuxTraceRandElements(" group(narr?) ")";
var r5 = RE2 l5.render;
var x5 = Match(r5, vlines.4);
match x5 with
| Some y => 
  println$  "L5: " + y.1;
| None => println$ "Parse 5 failed";
endmatch;

regdef l6 = "x: " group(number);
var r6 = RE2 l6.render;
var x6 = Match(r6, vlines.5);
match x6 with
| Some y => 
  println$  "L6: " + y.1;
| None => println$ "Parse 6 failed";
endmatch;

regdef l7 = "periodic_values: " group(narr);
var r7 = RE2 l7.render;
var x7 = Match(r7, vlines.6);
match x7 with
| Some y => 
  println$  "L7: " + y.1;
  var periodic_values = y.1;
| None => println$ "Parse 7 failed";
endmatch;

regdef l8 = "t_evaluations1: " group(narr);
var r8 = RE2 l8.render;
var x8 = Match(r8, vlines.7);
match x8 with
| Some y => 
var expected_evals = y.1;
  println$ "L8: " +  y.1;
| None => println$ "Parse 8 failed";
endmatch;

regdef l9 = "t_evaluations2: " group(narr);
var r9 = RE2 l9.render;
var x9 = Match(r9, vlines.8);
match x9 with
| Some y => 
  println$  "L9: " + y.1;
| None => println$ "Parse 9 failed";
endmatch;

regdef l10 = "t_combined: " group(number);
var r10 = RE2 l10.render;
var x10 = Match(r10, vlines.9);
match x10 with
| Some y => 
  println$  "L10: " + y.1;
| None => println$ "Parse 10 failed";
endmatch;

fun arr2list (x:string) {
  return split(x.[1 to -1],",");
}

var main_trace_len = (main_trace_current,",").split.len;

var output = 
"""
// GENERATED
%lang starknet

from starkware.cairo.common.cairo_builtins import BitwiseBuiltin
from starkware.cairo.common.hash import HashBuiltin
from starkware.cairo.common.alloc import alloc
from examples.tests.cairo.example import EvaluationFrame, evaluate_transition_0

@external
func test_transition_constraints{range_check_ptr}() {
    alloc_locals;
    let (periodic: felt*) = alloc();
"""
+
  {
    var ps = periodic_values.arr2list.varray;
    var s = "";
    for i in 0uz..<ps.len do
      &s <- s + "    assert periodic["+i.str+"] = "+ps.i.str+";\n";
    done
    return s;
  }()
    
+
"""
    let (current_frame: felt*) = alloc();
    let (next_frame: felt*) = alloc();
    %{
        current_frame_ptr = ids.current_frame
        for val in """ + main_trace_current + """:
               memory[current_frame_ptr] = val
               current_frame_ptr = current_frame_ptr + 1

        next_frame_ptr = ids.next_frame
        for next_val in """+main_trace_next+""":
            memory[next_frame_ptr] = next_val
            next_frame_ptr = next_frame_ptr + 1
    %}

    let (t_evaluations: felt*) = alloc();
    local t_evaluations_ptr: felt* = t_evaluations;
    let main_frame = EvaluationFrame("""+main_trace_len.str+""", current_frame, """+main_trace_len.str+""", next_frame);

    evaluate_transition_0(main_frame, t_evaluations, periodic);
    %{
        expected_t_evals = """+expected_evals+"""
        for i in range("""+main_trace_len.str+"""):
            print(i, memory[ids.t_evaluations_ptr + i])
            assert memory[ids.t_evaluations_ptr + i] == expected_t_evals[i]
    %}
    return ();
}
""";

save(test_filename, output);

